<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Abyssal Puzzle 3 | Abyssal Puzzle Rewind</title>
    <link rel="stylesheet" href="/three/common.css">
    <style>
        /* --- 基础和布局样式 --- */
        body {
            margin: 0;                      /* 移除默认边距 */
            padding: 0;                     /* 移除默认内边距 */
            background-color: #121212;      /* 深色背景 */
            color: #fff;                    /* 浅色文字 */
            font-family: Arial, sans-serif; /* 设置字体 */
            overflow: hidden;               /* 隐藏滚动条 */
            display: flex;                  /* 使用 Flexbox 布局 */
            justify-content: center;        /* 水平居中 */
            align-items: center;            /* 垂直居中 */
            min-height: 100vh;              /* 最小高度为视口高度 */
            /* 添加背景图片 */
            background-image: url('/three/img/background.jpeg');
            background-size: cover;         /* 图片覆盖整个背景区域 */
            background-repeat: no-repeat;   /* 图片不重复 */
            background-attachment: fixed;   /* 背景图片固定，不随滚动条滚动 */
            background-position: center;    /* 图片居中显示 */
        }
        /* --- 环形容器 --- */
        .ring-container {
            position: relative;             /* 作为内部绝对定位元素的参考 */
            width: 600px;                   /* 容器宽度 */
            height: 600px;                  /* 容器高度 */
        }

        /* --- 主圆环边框 --- */
        .main-ring {
            position: absolute;             /* 绝对定位 */
            width: 100%;                    /* 宽度占满容器 */
            height: 100%;                   /* 高度占满容器 */
            border: 4px solid rgba(204, 0, 0, .3); /* 红色半透明边框 */
            border-radius: 50%;             /* 圆形 */
            top: 0;                         /* 顶部对齐 */
            left: 0;                        /* 左侧对齐 */
            box-sizing: border-box;         /* 边框包含在宽高内 */
        }

        /* --- SVG 进度环 --- */
        .progress-svg {
            position: absolute;             /* 绝对定位 */
            width: 100%;                    /* 宽度占满容器 */
            height: 100%;                   /* 高度占满容器 */
            top: 0;                         /* 顶部对齐 */
            left: 0;                        /* 左侧对齐 */
            overflow: visible;              /* 允许内容（如发光效果或点）溢出 */
        }

        /* --- SVG 路径段 --- */
        .segment-path {
            fill: none;                     /* 无填充色 */
            stroke: #6cf;                   /* 路径颜色 (浅蓝色) */
            stroke-width: 5px;              /* 路径宽度 */
            stroke-linecap: round;          /* 路径端点为圆形 */
            opacity: 0;                     /* 初始透明 */
            transition: none;               /* 动画由 JS 控制，无需 CSS 过渡 */
        }

        /* --- SVG 移动的点 --- */
        .traveling-dot {
            fill: #fff;                     /* 点的颜色 (白色) */
            r: 5px;                         /* 点的半径 */
            display: none;                  /* 初始隐藏 */
        }

        /* --- 节点通用样式 --- */
        .node {
            position: absolute;             /* 绝对定位 */
            cursor: pointer;                /* 鼠标悬停时显示指针 */
            z-index: 2;                     /* 节点在 SVG 之上 */
            text-align: center;             /* 文本居中 (用于中心节点) */
            box-sizing: border-box;         /* 边框包含在宽高内 */
            border: 2px solid #fff;         /* 默认白色边框 */
            transition: background .3s ease, border-color .3s ease; /* 背景和边框颜色过渡 */
        }

        /* --- 节点形状和大小 (菱形、方形、中心) --- */
        .node.diamond, .node.square, .center-node {
            width: 40px;                    /* 常规节点宽度 */
            height: 40px;                   /* 常规节点高度 */
        }
        .node.diamond {
            background: #fff;               /* 菱形初始背景 (白色) */
            /* 旋转在 JS 中通过 transform 实现 */
        }
        .node.square {
            background: #333;               /* 方形初始背景 (深灰色) */
        }
        .center-node {
            width: 60px;                    /* 中心节点宽度 */
            height: 60px;                   /* 中心节点高度 */
            background: #333;               /* 中心节点初始背景 (深灰色) */
            opacity: .5;                    /* 中心节点初始半透明 */
            pointer-events: none;           /* 中心节点初始不可点击 */
            border-radius: 50%;             /* 中心节点为圆形 */
            display: flex;                  /* 使用 Flexbox 布局 */
            justify-content: center;        /* 内部文字水平居中 */
            align-items: center;            /* 内部文字垂直居中 */
            font-size: 14px;                /* 中心节点文字大小 */
            color: #fff;                    /* 中心节点文字颜色 */
            transition: opacity .3s ease, background .3s ease, color .3s ease, pointer-events .3s ease, border-color .3s ease; /* 多属性过渡 */
        }

        /* --- 解锁后的节点样式 --- */
        .node.unlocked.diamond, .node.unlocked.square {
            background: #6cf;               /* 解锁后背景色 (浅蓝色) */
            border-color: #6cf;             /* 解锁后边框色 (浅蓝色) */
        }
        /* --- 中心节点 'enabled' 样式 --- */
        /* 这个样式表示中心节点已准备好被点击以输入密码 */
        .center-node.enabled {
            opacity: 1;                     /* 启用后不透明 */
            pointer-events: auto;           /* 启用后可点击 */
            background: #fff;               /* 启用后背景色 (白色) */
            color: #121212;                 /* 启用后文字颜色 (深色) */
            cursor: pointer;                /* 鼠标悬停时显示指针 */
            border-color: #fff;             /* 边框颜色 (白色) */
        }

        /* --- 提示框样式 --- */
        .tooltip {
            position: fixed;                /* 固定定位，不随页面滚动 */
            right: 20px;                    /* 距离右边 20px */
            top: 20px;                      /* 距离顶部 20px */
            width: 300px;                   /* 提示框宽度 */
            height: 80vh;                   /* 提示框高度 (视口高度的80%) */
            background: #1e1e1e;            /* 提示框背景色 (深灰色) */
            border: 2px solid #fff;         /* 提示框边框 (白色) */
            overflow-y: auto;               /* 内容超出时显示垂直滚动条 */
            padding: 10px;                  /* 内边距 */
            box-sizing: border-box;         /* 内边距和边框包含在宽高内 */
            display: none;                  /* 初始隐藏 */
            z-index: 3;                     /* 在其他元素之上 */
            color: #ccc;                    /* 提示框文字颜色 (浅灰色) */
        }
        #tooltipContent {
            margin-bottom: 20px;            /* 内容区域距离下方密码区域的间距 */
            word-wrap: break-word;          /* 允许长单词换行 */
            white-space: pre-wrap;          /* 保留空白符和换行符 */
        }
        .tooltip p {
            margin: 0 0 10px;               /* 段落间距 */
            line-height: 1.5;               /* 行高 */
        }
        .tooltip a {
            color: #6cf;                    /* 链接颜色 (浅蓝色) */
            text-decoration: none;          /* 去掉下划线 */
            transition: color .2s ease, text-decoration .2s ease; /* 颜色和下划线过渡 */
        }
        .tooltip a:hover {
            color: #9cf;                    /* 悬停时更亮的蓝色 */
            text-decoration: underline;    /* 悬停时显示下划线 */
        }

        /* --- 密码表单样式 --- */
        .password-form {
            position: sticky;               /* 相对于 tooltip 滚动区域固定在底部 */
            bottom: 0;                      /* 固定在底部 */
            background: #1e1e1e;            /* 背景色与 tooltip 一致 */
            padding: 10px 0 0;              /* 顶部内边距 */
            margin: 0;                      /* 无外边距 */
            width: 100%;                    /* 宽度占满 tooltip */
            box-sizing: border-box;         /* 内边距包含在宽度内 */
        }
        .password-form input[type=text] {
            width: calc(100% - 18px);       /* 宽度计算 (考虑内边距和边框) */
            padding: 8px;                   /* 输入框内边距 */
            margin-bottom: 5px;             /* 输入框下方间距 */
            box-sizing: border-box;         /* 内边距和边框包含在宽度内 */
            background: #333;               /* 输入框背景 (深灰色) */
            color: #fff;                    /* 输入框文字颜色 (白色) */
            border: 1px solid #666;         /* 输入框边框 (灰色) */
            display: block;                 /* 块级元素，占满一行 */
        }
        .password-form button {
            width: 100%;                    /* 按钮宽度占满 */
            padding: 8px;                   /* 按钮内边距 */
            background: #4caf50;            /* 按钮背景色 (绿色) */
            color: #fff;                    /* 按钮文字颜色 (白色) */
            border: none;                   /* 无边框 */
            cursor: pointer;                /* 鼠标指针 */
            display: block;                 /* 块级元素 */
            transition: background .3s ease;/* 背景色过渡 */
        }
        .password-form button:not(:disabled):hover {
            background: #45a049;            /* 鼠标悬停时的背景色 (深绿色) */
        }
        .password-form button:disabled {
            background: #666;               /* 禁用时背景色 (灰色) */
            cursor: not-allowed;            /* 禁用时鼠标样式 */
        }

        /* --- 错误消息样式 --- */
        .error {
            color: red;                     /* 错误消息颜色 (红色) */
            text-align: center;             /* 文本居中 */
            margin-top: 5px;                /* 顶部外边距 */
            font-size: .9em;                /* 字体稍小 */
            min-height: 1.2em;              /* 最小高度，防止布局跳动 */
        }
    </style>
</head>
<body>
    <div id="message" style="position: fixed; top: 20px; left: 50%; transform: translateX(-50%); color: #fff; font-size: 18px; font-weight: bold; z-index: 2000; display: none; text-shadow: 0 0 5px rgba(0,0,0,0.5);"></div>
    <a href="/three/analysis" target="_blank" style="position: absolute; top: 10px; right: 10px; color: #6cf; text-decoration: underline; font-size: 14px; z-index: 10;">Abyssal Puzzle Rewind</a>
    <!-- === 背景音乐标签 === -->
    <audio id="backgroundAudio" loop> <!-- 移除 autoplay，由 JS 控制 -->
        <source src="/three/mp3/main.mp3" type="audio/mpeg">
        您的浏览器不支持音频元素。
    </audio>
    <!-- === 音频结束 === -->

    <div class="ring-container">
        <!-- 主圆环 -->
        <div class="main-ring"></div>
        <!-- 进度环 SVG -->
        <svg class="progress-svg" viewBox="0 0 600 600">
            <!-- 定义 6 个路径段 -->
            <path id="segmentPath-0-1" class="segment-path"/> <path id="segmentPath-1-2" class="segment-path"/>
            <path id="segmentPath-2-3" class="segment-path"/> <path id="segmentPath-3-4" class="segment-path"/>
            <path id="segmentPath-4-5" class="segment-path"/> <path id="segmentPath-5-0" class="segment-path"/>
            <!-- 移动的点 -->
            <circle id="travelingDot" class="traveling-dot"/>
        </svg>
        <!-- 节点组 -->
        <div class="nodes">
            <!-- 定义 6 个环形节点和 1 个中心节点 -->
            <div class="node diamond" data-index="0"></div> <div class="node square" data-index="1"></div>
            <div class="node square" data-index="2"></div> <div class="node square" data-index="3"></div>
            <div class="node square" data-index="4"></div> <div class="node square" data-index="5"></div>
            <div class="node center-node" id="centerNode" data-index="6">中心</div>
        </div>
    </div>

    <!-- 提示框 -->
    <div class="tooltip" id="tooltip">
        <!-- 节点说明内容区域 -->
        <div id="tooltipContent">这里是节点说明文字...</div>
        <!-- 密码输入表单区域 -->
        <div class="password-form" id="passwordForm">
            <input type="text" id="passwordInput" placeholder="请输入密码">
            <button id="unlockButton">解锁</button>
            <div class="error" id="errorMsg"></div> <!-- 显示错误或冷却信息 -->
        </div>
    </div>

<script src="/three/common.js"></script>
<script>
    // ========== 可配置参数 ==========
    const COOLDOWN_SECONDS = 10; // 冷却时间（秒）
    const PASSWORDS = {
        1: 'ESC',
        2: 'Y',
        3: '5',
        4: '5',
        5: 'RS',
        6: '你猜~喵~'
    };
    const nodeAngles = [90, 150, 210, 270, 330, 30]; // 各节点在圆环上的角度

    // ========== LocalStorage 操作函数 ==========
    function loadUnlockedState() {
        const saved = localStorage.getItem('abyssal_unlocked');
        if (saved) {
            try {
                const parsed = JSON.parse(saved);
                // 节点 0 始终是解锁的
                return [true, parsed[1], parsed[2], parsed[3], parsed[4], parsed[5]];
            } catch (e) {
                console.error('加载解锁状态失败:', e);
            }
        }
        return [true, false, false, false, false, false];
    }

    function saveUnlockedState(state) {
        localStorage.setItem('abyssal_unlocked', JSON.stringify({
            1: state[1],
            2: state[2],
            3: state[3],
            4: state[4],
            5: state[5]
        }));
    }
    const nodeDescriptions = [ // 各节点对应的说明文字
        "......", // 节点 0
        `<a href="https://www.bilibili.com/video/BV1SYqKYNESP" target="_blank">BV1SYqKYNESP</a> 范式天文台
<a href="https://www.bilibili.com/video/BV1b7KneCE7u" target="_blank">BV1b7KneCE7u</a> Arcaea光速神授说
tip:超链接指向的视频可能起到剧情氛围与范围方向提示作用，不作为必要信息参与解谜,请不要过于依赖视频信息.
两位探索者为了探寻音游世界的入口，穿梭于各个时空...
【层面1:医院】
两人坠入闪烁红光的实验室。一阵疾促的电子音响起：「滴滴滴滴滴 滴哒哒滴 哒哒哒哒滴 哒哒哒哒哒」。
破损的全息屏突然亮起显示"嘀哒"：「记录条：患者编号N」。
【层面2:塔】
“快看，到了”“别嚷嚷”。像素塔之下传来声音“滴哒哒滴 滴哒哒哒哒 滴滴滴滴滴 滴哒哒哒哒滴 滴哒哒滴 哒哒哒滴滴 滴滴滴滴滴”.奇怪的声音响完，世界突然倒了过来。两人摔了个踉跄。他们向前走了一步，抓住了谜题旁边柱子才勉强站稳。他们很快完成了谜题，并获得了一个评级。
【层面3:太空之诗】
宇宙飞船上，二人闲来无事，诗性大发，作诗一首：
最后一个信号在方程尽头结晶
猎枪卡进黎明的褶皱
信纸在星空背面生长褶皱
所有钟摆吞下箭的尾焰
恒星熄灭时灼烧网膜的酒精
时间在方程裂缝处开始脱水
左腿系着晨露编织的锚
右眼倒映着花序逆行的光斑
——这里每个意象都在回答同一道物理学谜题/概念
答案请以全大写字母形式呈现.
`, // 节点 1
        `<a href="https://www.bilibili.com/video/BV1tY4y1r7jJ" target="_blank">BV1tY4y1r7jJ</a> Phigros界面曲
tip:超链接指向的视频可能起到剧情氛围与范围方向提示作用，不作为必要信息参与解谜,请不要过于依赖视频信息.
两位探索者加速到光速从医院时空穿梭至一处山洞洞口...
任务执行日期:2023.xx.x+VII
两位探索者进入了一处石洞，石壁上画着三个生物，分别是：
鹖鴠 老虎 荔挺
鹖鴠上方打了"X"，老虎有两只且面对面，荔挺上方有一个类似于⬆️的符号.
石壁上还有一个巨大的像素塔壁画，像素塔顶画了"0:33 "旁边还有一小行文字"注意瞬时的形状".
三只生物下方有一串密文：
u=n¹(RUR＇U＇)
g=n²(RUR＇U＇R＇)
fᵘ=f
δᵍ=δ
n =n¹×n²

0 - b
1- c
..
25 - z
答案请以大写字母形式呈现
`, // 节点 2
        `<a href="https://www.bilibili.com/video/BV1o84y1479z" target="_blank">BV1o84y1479z</a> 范式起源Aweaken in Ruins曲目
tip:超链接指向的视频可能起到剧情氛围与范围方向提示作用，不作为必要信息参与解谜,请不要过于依赖视频信息.
两位探索者深入洞穴，发现了一本躺在角落的古书，书上有一些勉强可以辨认的文字：
历史在时间的轨道上疾驰.
各地日蚀最佳观测时间:
埃菲尔铁塔:
4:00~8:00
悉尼歌剧院:
4:00~8:00
时代广场:
6:00~10:00
将日蚀现象的六种颜色从小到大排列，找到第四种颜色并连接WIFI.
WIFI名:Code ZeroWithfour
密码:Overture
答案在4字节及以内
`, // 节点 3
        `<a href="https://www.bilibili.com/video/BV1ee4y1M7wW" target="_blank">BV1ee4y1M7wW</a> maimai天空街曲目群青
tip:超链接指向的视频可能起到剧情氛围与范围方向提示作用，不作为必要信息参与解谜,请不要过于依赖视频信息.
两位探索者进入到了洞窟最深处，捡到了一支录音笔，按动开关放出了声音...
我们的旅程仍在继续
[蝴蝶印记消失了......]
[一定要找到???才行]
Code :[ふらふらふら]
Password:ZrfZaylla
不清楚也没关系
还有备用的
Code2:[シックスプラン]
Password:ZrfZaylla
[你究竟期待着怎样的结局]
（寻找那区域中的序列印记）
July
答案在5字节及以内
`, // 节点 4
        `<a href="https://www.bilibili.com/video/BV1QS4y1J7BK" target="_blank">BV1QS4y1J7BK</a>
tip:超链接指向的视频可能起到剧情氛围与范围方向提示作用，不作为必要信息参与解谜,请不要过于依赖视频信息.
录音笔播放完声音后发出了警告声，洞穴开始垮塌，两个人慌忙往外跑，却被一道石门堵住.两个人在洞穴四周的岩壁上找到了一张地图，旁边是一些古老的雕刻文字：
"多希望能下一场雪啊"
"是啊，当年第一场洁白的雪，滋润了这片土地”
”这片土地'见证'了多少文明的兴盛与衰落至极啊...”
找到全部快速发展的历史的总和+10001101，你会找到你想要的答案.
地图上没有什么重要的信息，唯独在上下左右四个边上分别居中写了一些数字，每个数字都有一个指向它的箭头，似乎对应着象征着某种规律:
14 19 23 5
答案请以大写字母形式呈现
`, // 节点 5
        // <--- 修改中心节点描述 --->
        `Ancient civilization blooms bright flowers in modern times.
两位探索者逃出石洞以后，看到了洞口突然冒出的祭坛，四周的石柱上刻着字：
1-小寒
2-立夏
3-大寒
4-小暑
祭坛上写着：
纠正时间漏洞,依次排列石柱并将岁首移至岁末，'0'=A，在你们的生活中找到他.
答案请以多重文字字符呈现.中间无空格，若有符号请使用英文符号
` // 节点 6 (中心)
    ];
    const animationDuration = 1000; // 单个路径段动画时长 (毫秒)
    const fullCircleSegmentDuration = 1000; // 闭合圆环动画时长 (毫秒)
    const NEXT_PAGE_URL = '/three/next'; // 点击中心节点后跳转的页面
    // ========== 配置结束 ==========

    // --- 获取 DOM 元素 ---
    const nodes = document.querySelectorAll('.node');
    const tooltip = document.getElementById('tooltip');
    const tooltipContent = document.getElementById('tooltipContent');
    const passwordForm = document.getElementById('passwordForm');
    const passwordInput = document.getElementById('passwordInput');
    const unlockButton = document.getElementById('unlockButton');
    const errorMsg = document.getElementById('errorMsg');
    const centerNode = document.getElementById('centerNode');
    const travelingDot = document.getElementById('travelingDot');
    const audioElement = document.getElementById('backgroundAudio');
    const segmentPaths = [];
    for (let i = 0; i < 6; i++) {
        segmentPaths.push(document.getElementById(`segmentPath-${i}-${(i + 1) % 6}`));
    }

    // --- 状态变量 ---
    let unlockedNodes = loadUnlockedState(); // 从 localStorage 加载解锁状态
    let isCenterEnabled = false; // 中心节点是否“准备好”被点击以输入密码
    let currentNodeIndex = null; // 当前交互的节点索引 (0-6)
    const radius = 298; // 圆环半径
    const containerSize = 600; // 容器大小
    const circleCenterX = containerSize / 2; // 圆心 X
    const circleCenterY = containerSize / 2; // 圆心 Y

    // --- 初始化 CooldownManager ---
    const cooldownManager = new CooldownManager({
        cookieName: 'abyssal_cooldown',
        cooldownSeconds: COOLDOWN_SECONDS,
        inputElement: passwordInput,
        buttonElement: unlockButton,
        errorElement: errorMsg,
        formElement: passwordForm,
        buttonDefaultText: '解锁',
        buttonLoadingText: '验证中...',
        onCooldownEnd: () => {
            console.log('冷却结束。');
        }
    });

    // --- 初始化设置 ---
    positionNodes();
    createSegmentPaths();
    const startNodeElement = document.querySelector('.node[data-index="0"]');
    if (startNodeElement) startNodeElement.classList.add('unlocked');

    // 恢复已解锁节点的视觉状态
    unlockedNodes.forEach((unlocked, index) => {
        if (unlocked && index > 0) {
            const targetNode = document.querySelector(`.node[data-index="${index}"]`);
            if (targetNode) targetNode.classList.add('unlocked');
            const segmentIndex = index - 1;
            const pathElement = segmentPaths[segmentIndex];
            if (pathElement) {
                pathElement.style.opacity = 1;
                pathElement.style.stroke = '#6cf';
                pathElement.style.strokeDashoffset = 0;
            }
        }
    });

    // 检查是否所有环形节点都已解锁，启用中心节点
    if (unlockedNodes.slice(1, 6).every(Boolean)) {
        enableCenterNode();
    }

    // --- 函数定义 ---

    /** 计算节点 SVG 坐标 */
    function calculateNodeSvgPosition(angleDeg) {
        const angleRad = angleDeg * Math.PI / 180;
        return {
            x: circleCenterX + radius * Math.cos(angleRad),
            y: circleCenterY + radius * Math.sin(angleRad)
        };
    }

    /** 定位所有节点 */
    function positionNodes() {
        nodes.forEach((node) => {
            const index = parseInt(node.dataset.index);
            if (index === 6) { // 中心节点
                node.style.left = '50%';
                node.style.top = '50%';
                node.style.transform = 'translate(-50%, -50%)';
            } else { // 环形节点
                const angleDeg = nodeAngles[index];
                const svgPos = calculateNodeSvgPosition(angleDeg);
                node.style.top = `${svgPos.y}px`;
                node.style.left = `${svgPos.x}px`;
                let transform = 'translate(-50%, -50%)';
                if (node.classList.contains('diamond')) transform += ' rotate(45deg)';
                node.style.transform = transform;
            }
        });
    }

    /** 创建 SVG 路径 */
    function createSegmentPaths() {
        for (let i = 0; i < 6; i++) {
            const startPos = calculateNodeSvgPosition(nodeAngles[i]);
            const endPos = calculateNodeSvgPosition(nodeAngles[(i + 1) % 6]);
            const pathData = `M ${startPos.x} ${startPos.y} A ${radius} ${radius} 0 0 1 ${endPos.x} ${endPos.y}`;
            const pathElement = segmentPaths[i];
            if (pathElement) {
                pathElement.setAttribute('d', pathData);
                const pathLength = pathElement.getTotalLength();
                pathElement.style.strokeDasharray = pathLength;
                pathElement.style.strokeDashoffset = pathLength;
                pathElement.style.opacity = 0;
            }
        }
    }

    /** 显示提示框 */
    function showTooltip(nodeIndexToShow, needsPassword, cooldownMessage = null, remainingSeconds = 0) {
        if (nodeIndexToShow === null || nodeDescriptions[nodeIndexToShow] === undefined) {
             console.warn("showTooltip called with invalid index:", nodeIndexToShow);
             return;
        }
        tooltip.style.display = 'block';
        tooltipContent.innerHTML = nodeDescriptions[nodeIndexToShow];
        passwordInput.value = '';
        cooldownManager.clearCooldownState(true); // 总是先清理之前的状态和消息

        if (cooldownMessage) { // 情况1: 传入了冷却信息
            passwordForm.style.display = 'block'; // 密码区可见但禁用
            passwordForm.classList.add('cooldown-active');
            passwordInput.disabled = true;
            unlockButton.disabled = true;
            unlockButton.textContent = '请等待...';
            errorMsg.textContent = cooldownMessage; // 显示传入的冷却消息
            cooldownManager.startFrontendCooldownTimers(remainingSeconds); // 启动前端计时器
        } else if (needsPassword) { // 情况2: 需要密码输入
            passwordForm.style.display = 'block';
        } else { // 情况3: 只显示信息 (如节点0，或未启用的中心节点)
            passwordForm.style.display = 'none';
        }
        tooltip.scrollTop = 0; // 滚动到顶部
    }


    /** 异步检查密码 */
    function checkPassword() {
        // 检查当前节点索引是否有效 (1-6)
        if (currentNodeIndex === null || ![1, 2, 3, 4, 5, 6].includes(currentNodeIndex)) {
             console.warn("checkPassword called with invalid index:", currentNodeIndex);
             return;
        }
        const input = passwordInput.value;
        const indexToCheck = currentNodeIndex; // 保存当前索引，以防在操作中被修改

        // 禁用输入和按钮，显示验证状态
        unlockButton.disabled = true;
        passwordInput.disabled = true;
        unlockButton.textContent = '验证中...';
        errorMsg.textContent = ''; // 清除之前的错误信息
        passwordForm.classList.remove('cooldown-active'); // 移除冷却样式
        cooldownManager.clearCooldownState(false); // 清理前端计时器但不立即清除消息

        // 前端验证密码
        const correctPassword = PASSWORDS[indexToCheck];
        if (input === correctPassword) {
            // 密码正确
            console.log(`节点 ${indexToCheck} 密码正确。`);
            tooltip.style.display = 'none'; // 关闭提示框
            cooldownManager.clearCooldownState(true); // 清理所有状态和消息
            cooldownManager.clearCooldown(); // 清除冷却 cookie

            // --- 根据节点索引决定行为 ---
            if (indexToCheck >= 1 && indexToCheck <= 5) { // 环形节点 (1-5)
                if (!unlockedNodes[indexToCheck]) { // 确保只在首次解锁时执行
                    unlockedNodes[indexToCheck] = true; // 更新解锁状态
                    saveUnlockedState(unlockedNodes); // 保存到 localStorage
                    const targetNode = document.querySelector(`.node[data-index="${indexToCheck}"]`);
                    const segmentIndex = indexToCheck - 1; // 路径段索引比节点索引小 1

                    if (indexToCheck === 5) { // 解锁最后一个环形节点 (5)
                        // 动画第 5 段 (4->5)
                        animatePathSegment(segmentIndex, fullCircleSegmentDuration, () => {
                            if (targetNode) targetNode.classList.add('unlocked'); // 更新节点样式
                            // 动画第 6 段 (5->0)，闭合圆环
                            animatePathSegment(5, fullCircleSegmentDuration, () => {
                                // 确保所有路径段都可见且颜色一致
                                segmentPaths.forEach(p => { p.style.opacity = 1; p.style.stroke = '#6cf'; p.style.strokeDashoffset = 0; });
                                // 检查是否所有 1-5 节点都已解锁
                                if (unlockedNodes.slice(1, 6).every(Boolean)) {
                                    enableCenterNode(); // 启用中心节点
                                }
                            });
                        });
                    } else { // 解锁中间的环形节点 (1-4)
                        // 动画对应的路径段
                        animatePathSegment(segmentIndex, animationDuration, () => {
                            if (targetNode) targetNode.classList.add('unlocked'); // 更新节点样式
                            // 检查是否所有 1-5 节点都已解锁 (每次解锁后都检查)
                            if (unlockedNodes.slice(1, 6).every(Boolean)) {
                                enableCenterNode(); // 启用中心节点
                            }
                        });
                    }
                } else {
                    // 节点已经解锁
                    console.log(`节点 ${indexToCheck} 已经解锁。`);
                    // 显示提示后关闭
                    alert('该节点已经解锁！');
                }
            } else if (indexToCheck === 6) { // 中心节点 (6)
                console.log("中心节点密码正确，准备跳转...");
                window.location.href = NEXT_PAGE_URL; // 执行页面跳转
            }
            // --- 结束：根据节点索引决定行为 ---

            currentNodeIndex = null; // 重置当前节点

        } else {
            // 密码错误
            console.log(`节点 ${indexToCheck} 密码错误！`);
            passwordInput.value = ''; // 清空密码输入框
            cooldownManager.setCooldown(); // 设置冷却 cookie
            const cooldownStatus = cooldownManager.checkCooldown();
            errorMsg.textContent = `密码错误！请等待 ${cooldownStatus.remaining} 秒...`;
            cooldownManager.startFrontendCooldownTimers(cooldownStatus.remaining); // 启动前端冷却计时器
        }
    }

    /** 动画 SVG 路径 */
    function animatePathSegment(segmentIndex, duration, onComplete = null) {
        const pathElement = segmentPaths[segmentIndex];
        if (!pathElement) { // 如果路径元素不存在
            console.warn(`路径段 ${segmentIndex} 未找到！`);
            if (onComplete) onComplete(); // 如果有回调，仍然执行它
            return;
        }
        const pathLength = pathElement.getTotalLength();
        if (pathLength === 0) { // 如果路径长度为 0 (可能由于定位问题)
            console.warn(`路径段 ${segmentIndex} 长度为 0！`);
            pathElement.style.opacity = 1; // 尝试直接显示路径
            pathElement.style.strokeDashoffset = 0;
            if (onComplete) onComplete();
            return;
        }

        pathElement.style.opacity = 1; // 使路径可见
        pathElement.style.strokeDasharray = pathLength; // 设置虚线长度为总长
        pathElement.style.strokeDashoffset = pathLength; // 设置偏移量为总长（路径完全隐藏）

        const startPoint = pathElement.getPointAtLength(0); // 获取路径起点
        travelingDot.setAttribute('cx', startPoint.x); // 设置点的初始 X 坐标
        travelingDot.setAttribute('cy', startPoint.y); // 设置点的初始 Y 坐标
        travelingDot.style.display = 'block'; // 显示点

        let startTime = null;

        function step(timestamp) {
            if (!startTime) startTime = timestamp; // 记录动画开始时间
            const elapsed = timestamp - startTime; // 计算经过的时间
            const progress = Math.min(elapsed / duration, 1); // 计算动画进度 (0 到 1)

            const currentLength = pathLength * progress; // 计算当前绘制的长度
            const currentPoint = pathElement.getPointAtLength(currentLength); // 获取当前进度对应的点坐标

            // 更新点的位置
            travelingDot.setAttribute('cx', currentPoint.x);
            travelingDot.setAttribute('cy', currentPoint.y);

            // 更新路径的可见部分 (减少偏移量)
            pathElement.style.strokeDashoffset = pathLength - currentLength;

            if (progress < 1) { // 如果动画未完成
                requestAnimationFrame(step); // 请求下一帧
            } else { // 动画完成
                pathElement.style.strokeDashoffset = 0; // 确保路径完全显示
                travelingDot.style.display = 'none'; // 隐藏点
                if (onComplete) onComplete(); // 执行回调函数
            }
        }
        requestAnimationFrame(step); // 启动动画
    }

    /** 启用中心节点 - 修改后：仅标记为准备就绪 */
    function enableCenterNode() {
        if (!isCenterEnabled) { // 确保只执行一次
            isCenterEnabled = true; // 更新状态
            centerNode.classList.add('enabled'); // 应用 'enabled' 样式，使其看起来可交互
            console.log("中心节点已准备就绪，可以点击输入密码。");
            // 不再在此处直接跳转，而是等待用户点击和输入密码
        }
    }

    // --- 音频播放逻辑 ---
    const audioPlayer = new AudioPlayer(audioElement, {
        autoPlayOnFirstClick: false,
        showControlButton: true,
        controlButton: null // 将在后面创建
    });

    // 创建音乐控制按钮
    const musicControlButton = document.createElement('button');
    musicControlButton.className = 'music-control';
    musicControlButton.textContent = '播放音乐';
    document.body.appendChild(musicControlButton);
    audioPlayer.controlButton = musicControlButton;
    audioPlayer.setupControlButton();

    // --- 消息提示函数 ---
    function showMessage(text) {
        const msg = document.getElementById('message');
        msg.textContent = text;
        msg.style.display = 'block';
        setTimeout(() => {
            msg.style.display = 'none';
        }, 2000);
    }

    // --- 节点点击事件 ---
    nodes.forEach(node => {
        const index = parseInt(node.dataset.index); // 获取节点的索引

        if (index === 6) { // --- 特别处理中心节点 (index 6) ---
            node.addEventListener('click', (e) => {
                 e.stopPropagation(); // 阻止事件冒泡

                 if (!isCenterEnabled) { // 如果中心节点尚未被启用（环形节点未全部解锁）
                     console.log("中心节点尚未启用。");
                     // 显示中心节点的描述信息（提示需要先解锁环形节点）
                     currentNodeIndex = index; // 设置当前交互节点
                     showTooltip(index, false); // 显示信息，不需要密码
                     return; // 结束处理
                 }

                 // --- 中心节点已启用，进入密码验证流程 ---

                 // 检查是否在冷却或验证中，如果是并且点击了不同的节点，则阻止切换
                 if (tooltip.style.display === 'block' && passwordInput.disabled && currentNodeIndex !== index) {
                     console.log("在冷却或验证期间阻止了节点切换。");
                     return;
                 }
                 // 如果 tooltip 已打开且点击了不同节点，则先关闭旧的
                 if (tooltip.style.display === 'block' && currentNodeIndex !== null && currentNodeIndex !== index) {
                     tooltip.style.display = 'none';
                     cooldownManager.clearCooldownState(true); // 清理旧状态
                 }

                 currentNodeIndex = index; // 设置当前交互节点为中心节点 (6)

                 // === 检查冷却状态 ===
                 console.log(`中心节点 (${index}) 被点击，正在检查冷却状态...`);
                 tooltip.style.display = 'block'; // 先显示 tooltip 骨架
                 passwordForm.style.display = 'none'; // 初始隐藏密码输入区域
                 tooltipContent.innerHTML = nodeDescriptions[index]; // 显示中心节点的描述

                 const cooldownStatus = cooldownManager.checkCooldown();
                 if (cooldownStatus.cooldown && cooldownStatus.remaining > 0) {
                     // --- 冷却中 ---
                     console.log(`中心节点 (${index}): 冷却中 (${cooldownStatus.remaining}s 剩余). 显示冷却信息。`);
                     showTooltip(index, false, `请求过于频繁，请等待 ${cooldownStatus.remaining} 秒...`, cooldownStatus.remaining);
                 } else {
                     // --- 不在冷却中 ---
                     console.log(`中心节点 (${index}): 不在冷却中。显示密码输入提示。`);
                     showTooltip(index, true); // 第二个参数 true 表示需要密码
                 }
            });

        } else { // --- 处理环形节点 (0-5) ---
            node.addEventListener('click', (e) => {
                 e.stopPropagation(); // 阻止事件冒泡

                 // 检查是否在冷却或验证中，如果是并且点击了不同的节点，则阻止切换
                 if (tooltip.style.display === 'block' && passwordInput.disabled && currentNodeIndex !== index) {
                     console.log("在冷却或验证期间阻止了节点切换。");
                     return;
                 }
                 // 如果 tooltip 已打开且点击了不同节点，则先关闭旧的
                 if (tooltip.style.display === 'block' && currentNodeIndex !== null && currentNodeIndex !== index) {
                     tooltip.style.display = 'none';
                     cooldownManager.clearCooldownState(true); // 清理旧状态
                 }

                 currentNodeIndex = index; // 设置当前交互节点

                 // 检查前置节点是否已解锁 (仅对 1-5 有效)
                 if (index > 0 && index <= 5 && !unlockedNodes[index - 1]) {
                     showMessage("请按顺序解锁前一个节点！"); // 提示用户
                     currentNodeIndex = null; // 重置当前节点
                     tooltip.style.display = 'none'; // 关闭 tooltip
                     cooldownManager.clearCooldownState(true); // 清理状态
                     return; // 结束处理
                 }

                 // 判断是否需要输入密码 (节点 1-5 且尚未解锁)
                 const needsPasswordCheck = index >= 1 && index <= 5 && !unlockedNodes[index];

                 if (needsPasswordCheck) {
                     // === 需要密码：检查冷却状态 ===
                     console.log(`节点 ${index} 被点击，需要密码，正在检查冷却状态...`);
                     tooltip.style.display = 'block'; // 显示 tooltip 骨架
                     passwordForm.style.display = 'none'; // 隐藏密码区
                                         tooltipContent.innerHTML = nodeDescriptions[index]; // 显示节点描述
                     
                                         const cooldownStatus = cooldownManager.checkCooldown();
                                         if (cooldownStatus.cooldown && cooldownStatus.remaining > 0) {                         // --- 冷却中 ---
                         console.log(`节点 ${index}: 冷却中 (${cooldownStatus.remaining}s 剩余).`);
                         showTooltip(index, false, `请求过于频繁，请等待 ${cooldownStatus.remaining} 秒...`, cooldownStatus.remaining);
                     } else {
                         // --- 不在冷却中 ---
                         console.log(`节点 ${index}: 不在冷却中。显示密码输入。`);
                         showTooltip(index, true); // 显示带密码框的 Tooltip
                     }
                 } else {
                      // --- 不需要密码 (节点 0 或已解锁的 1-5) ---
                      console.log(`节点 ${index} 被点击，仅显示信息。`);
                      showTooltip(index, false); // 只显示信息，不需要密码
                 }
            });
        }
    });

    // --- 解锁按钮点击 ---
    unlockButton.addEventListener('click', checkPassword);

    // --- 密码框回车 ---
    passwordInput.addEventListener('keypress', function(event) {
        // 如果按下的是 Enter 键且输入框未被禁用
        if (event.key === 'Enter' && !passwordInput.disabled) {
            event.preventDefault(); // 阻止默认的回车行为 (如表单提交)
            checkPassword(); // 调用密码检查函数
        }
    });

    // --- 点击外部关闭 tooltip ---
    document.addEventListener('click', (e) => {
         // 检查 tooltip 是否可见，并且点击的目标不是 tooltip 自身或其子元素，也不是任何节点
         if (tooltip.style.display === 'block'
             && !e.target.closest('.tooltip')
             && !e.target.closest('.node'))
         {
             // 只有在输入框和按钮未被禁用时（即非冷却/验证状态）才允许关闭
             if (!passwordInput.disabled) {
                 tooltip.style.display = 'none'; // 关闭 tooltip
                 currentNodeIndex = null; // 重置当前节点
                 cooldownManager.clearCooldownState(true); // 清理状态和消息
             } else {
                 console.log("在冷却/验证期间阻止了点击外部关闭 tooltip。");
             }
        }
    });

</script>
</body>
</html>